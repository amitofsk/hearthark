"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBearerTokenFromCreds = exports.GenerateToken = exports.generateBearerToken = void 0;
const fs_1 = __importDefault(require("fs"));
const axios_1 = __importDefault(require("axios"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const Messages_1 = require("../errors/Messages");
const logsHelper_1 = require("../../vault-api/utils/logsHelper");
const logs_1 = __importDefault(require("../../vault-api/utils/logs"));
const common_1 = require("../../vault-api/utils/common");
function generateBearerToken(credentialsFilePath) {
    return new Promise((resolve, reject) => {
        let credentials;
        if (!fs_1.default.existsSync(credentialsFilePath)) {
            reject(Messages_1.errorMessages.fileNotFound);
        }
        credentials = fs_1.default.readFileSync(credentialsFilePath, "utf8");
        if (credentials === '')
            reject(Messages_1.errorMessages.EmptyFile);
        try {
            JSON.parse(credentials);
        }
        catch (e) {
            reject(Messages_1.errorMessages.notAValidJSON);
        }
        getToken(credentials).then((res) => {
            resolve(res);
        }).catch((err) => { reject(err); });
    });
}
exports.generateBearerToken = generateBearerToken;
function getToken(credentials) {
    return new Promise((resolve, reject) => {
        if (!credentials && credentials == "") {
            reject(Messages_1.errorMessages.CredentialsContentEmpty);
        }
        if (typeof (credentials) !== "string") {
            reject(Messages_1.errorMessages.ExpectedStringParameter);
        }
        const credentialsObj = JSON.parse(credentials);
        const expiryTime = Math.floor(Date.now() / 1000) + 3600;
        const claims = {
            iss: credentialsObj.clientID,
            key: credentialsObj.keyID,
            aud: credentialsObj.tokenURI,
            exp: expiryTime,
            sub: credentialsObj.clientID,
        };
        if (claims.iss == null) {
            reject(Messages_1.errorMessages.clientIDNotFound);
        }
        if (claims.key == null) {
            reject(Messages_1.errorMessages.keyIDNotFound);
        }
        if (claims.aud == null) {
            reject(Messages_1.errorMessages.tokenURINotFound);
        }
        if (credentialsObj.privateKey == null) {
            reject(Messages_1.errorMessages.privateKeyNotFound);
        }
        const privateKey = credentialsObj.privateKey.toString("utf8");
        const signedJwt = jsonwebtoken_1.default.sign(claims, privateKey, { algorithm: "RS256" });
        (0, axios_1.default)(`${credentialsObj.tokenURI}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: {
                grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
                assertion: signedJwt,
            },
        })
            .then((res) => {
            resolve({
                accessToken: res.data.accessToken,
                tokenType: res.data.tokenType,
            });
        })
            .catch((err) => {
            reject(err);
        });
    });
}
function GenerateToken(credentialsFilePath) {
    (0, logsHelper_1.printLog)(logs_1.default.warnLogs.GENERATE_BEARER_DEPRECATED, common_1.MessageType.WARN);
    return generateBearerToken(credentialsFilePath);
}
exports.GenerateToken = GenerateToken;
function generateBearerTokenFromCreds(credentials) {
    return getToken(credentials);
}
exports.generateBearerTokenFromCreds = generateBearerTokenFromCreds;
//# sourceMappingURL=Token.js.map